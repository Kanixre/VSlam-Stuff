Links and Commands
---------------------------------------------------------------------------------------------------
https://lcas.lincoln.ac.uk/nextcloud/index.php/s/q73JHG6xWwX3Lqf

-----
roscore
rosrun ORB_SLAM3 Mono Vocabulary/ORBvoc.txt Examples_old/ZED2.yaml
rosbag play --pause kg_lc_march.bag # replace with desired bag name
rosrun image_transport republish compressed in:=/front/zed_node/rgb/image_rect_color raw out:=/camera/image_raw

------
evo_ape tum GPS_march.tum KeyFrameTrajectory_yz.txt --verbose --align --correct_scale

evo_traj tum  KeyFrameTrajectory.txt -vap --ref GPS_march.tum --correct_scale
------------
#!/usr/bin/env python

import rospy
from sensor_msgs.msg import CompressedImage, Image
import cv2
from cv_bridge import CvBridge, CvBridgeError
import numpy as np

class ImageSegmentationNode:
    def __init__(self):
        self.bridge = CvBridge()

        # Subscribe to the compressed image topic from the ROS bag
        self.image_sub = rospy.Subscriber('/camera/image/compressed', CompressedImage, self.image_callback)

        # Publisher for the segmented image (this would be the input for ORB-SLAM3)
        self.image_pub = rospy.Publisher('/segmented_image', Image, queue_size=1)

    def image_callback(self, msg):
        try:
            # Decompress the image
            np_arr = np.frombuffer(msg.data, np.uint8)
            cv_image = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)

            # Perform segmentation (replace with your model's processing function)
            segmented_image = self.process_segmentation(cv_image)

            # Convert the segmented image back to ROS Image message
            segmented_msg = self.bridge.cv2_to_imgmsg(segmented_image, "bgr8")

            # Publish the segmented image
            self.image_pub.publish(segmented_msg)

        except CvBridgeError as e:
            rospy.logerr("CvBridgeError: {0}".format(e))

    def process_segmentation(self, image):
        # Default to the input image in case of any failure in segmentation
        segmented_image = image
        
        try:
            # Replace this with your actual segmentation model
            # For example:
            # segmented_image = your_segmentation_model(image)

            # Just for demonstration, return the original image
            segmented_image = image

        except Exception as e:
            rospy.logerr("Segmentation model error: {0}".format(e))

        return segmented_image

if __name__ == '__main__':
    rospy.init_node('image_segmentation_node', anonymous=True)
    node = ImageSegmentationNode()
    try:
        rospy.spin()
    except KeyboardInterrupt:
        rospy.loginfo("Shutting down")

---------------------------------------------------------------------------------------------------
#!/usr/bin/env python

import rospy
from sensor_msgs.msg import CompressedImage, Image
import cv2
from cv_bridge import CvBridge, CvBridgeError
import numpy as np

class ImageSegmentationNode:
    def __init__(self):
        self.bridge = CvBridge()

        # Subscribe to the compressed image topic from the ROS bag
        self.image_sub = rospy.Subscriber('/camera/image/compressed', CompressedImage, self.image_callback)

        # Publisher for the segmented image (this would be the input for ORB-SLAM3)
        self.image_pub = rospy.Publisher('/segmented_image', Image, queue_size=1)

    def image_callback(self, msg):
        try:
            # Decompress the image
            np_arr = np.fromstring(msg.data, np.uint8)
            cv_image = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)

            # Perform segmentation (replace with your model's processing function)
            segmented_image = self.process_segmentation(cv_image)

            # Convert the segmented image back to ROS Image message
            segmented_msg = self.bridge.cv2_to_imgmsg(segmented_image, "bgr8")

            # Publish the segmented image
            self.image_pub.publish(segmented_msg)

        except CvBridgeError as e:
            rospy.logerr("CvBridgeError: {0}".format(e))

    def process_segmentation(self, image):
        # Replace this with your actual segmentation model
        # For example, if using a pre-trained deep learning model:
        # segmented_image = your_segmentation_model(image)

        # Here we'll just return the original image for the sake of example
        return image

if __name__ == '__main__':
    rospy.init_node('image_segmentation_node', anonymous=True)
    node = ImageSegmentationNode()
    try:
        rospy.spin()
    except KeyboardInterrupt:
        rospy.loginfo("Shutting down")

---------------------------------------------------------------------------------------------------

header:
frame_id: "front_left_camera_optical_frame"
 
height: 1080
width: 1920
 
distortion_model: "plumb_bob"
 
D: [0.0, 0.0, 0.0, 0.0, 0.0]
 
K: [1057.0008544921875,       0.0,                952.2301635742188,
     0.0,                  1057.0008544921875,      553.5770263671875,     
     0.0,                                      0.0,                                           1.0]
 
R: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]
 
P: [1057.0008544921875,       0.0,                952.2301635742188,
      0.0,                                     0.0,              1057.0008544921875,
      553.5770263671875,         0.0,                                            0.0,
      0.0,                                     1.0,                                           0.0]
 
binning_x: 0
binning_y: 0
roi:
x_offset: 0
y_offset: 0
height: 0
width: 0
do_rectify: False1920


https://arxiv.org/abs/2007.11898

